(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{191:function(t,a,_){"use strict";_.r(a);var s=_(0),v=Object(s.a)({},(function(){this._self._c;return this._m(0)}),[function(){var t=this,a=t._self._c;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"高级算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高级算法"}},[t._v("#")]),t._v(" 高级算法")]),t._v(" "),a("h2",{attrs:{id:"动态规划"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动态规划"}},[t._v("#")]),t._v(" 动态规划")]),t._v(" "),a("p",[t._v("动态规划有时候被认为跟递归是一种相反的技术。递归是自顶向下的，它是从顶部分解问题。解决掉所有分解出来的小问题的方式。\n动态规划是从底部开始解决问题。将所有小问题解决掉 合并成一个整体的解决方案。从而解决掉大问题，")]),t._v(" "),a("h3",{attrs:{id:"动态规划的三要素"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动态规划的三要素"}},[t._v("#")]),t._v(" 动态规划的三要素")]),t._v(" "),a("ul",[a("li",[t._v("最优子结构 最优解")]),t._v(" "),a("li",[t._v("边界条件")]),t._v(" "),a("li",[t._v("状态和状态转移公式")])]),t._v(" "),a("h3",{attrs:{id:"多阶段决策最优解模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多阶段决策最优解模型"}},[t._v("#")]),t._v(" "),a("strong",[t._v("多阶段决策最优解模型")])]),t._v(" "),a("p",[t._v("动态规划一般用来解决最优解问题，分解解决问题的过程中需要经历多个决策阶段。每个决策阶段对应着一组状态，通过这些决策来求解期望的最优解。")]),t._v(" "),a("h4",{attrs:{id:"_1、最优子结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、最优子结构"}},[t._v("#")]),t._v(" 1、最优子结构")]),t._v(" "),a("p",[t._v("问题的最优解和子问题的最优解，可以通过子问题的最优解来推导问题的最优解。这样后面的阶段状态可以通过前面的状态推导出。")]),t._v(" "),a("h4",{attrs:{id:"_2、无后效性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、无后效性"}},[t._v("#")]),t._v(" 2、无后效性")]),t._v(" "),a("p",[t._v("在推导后面阶段的状态的时候，我们只关心前面阶段的状态值。不关心这个状态是怎么推导的。第二 某个状态一旦确定，就不受之后阶段决策的影响\n无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划最优解模型。")]),t._v(" "),a("h4",{attrs:{id:"_3、重复的子问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、重复的子问题"}},[t._v("#")]),t._v(" 3、重复的子问题")]),t._v(" "),a("p",[t._v("不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态")]),t._v(" "),a("h3",{attrs:{id:"动态规划的解题步骤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动态规划的解题步骤"}},[t._v("#")]),t._v(" 动态规划的解题步骤")]),t._v(" "),a("p",[t._v("动态规划的核心思想是"),a("strong",[t._v("递推")]),t._v("。 难点在于想起 状态 DP[i]代表什么。然后构造状态转移矩阵，利用初始条件递推出最终结果。")]),t._v(" "),a("ul",[a("li",[t._v("将原问题拆分成子问题")]),t._v(" "),a("li",[t._v("确认状态")]),t._v(" "),a("li",[t._v("确认边界状态（初始条件）")]),t._v(" "),a("li",[t._v("状态转移方程")])])])}],!1,null,null,null);a.default=v.exports}}]);