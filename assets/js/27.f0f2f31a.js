(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{194:function(t,_,v){"use strict";v.r(_);var s=v(0),a=Object(s.a)({},(function(){this._self._c;return this._m(0)}),[function(){var t=this,_=t._self._c;return _("div",{staticClass:"content"},[_("h1",{attrs:{id:"算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#算法"}},[t._v("#")]),t._v(" 算法")]),t._v(" "),_("h2",{attrs:{id:"排序算法（bubble-sort）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#排序算法（bubble-sort）"}},[t._v("#")]),t._v(" 排序算法（Bubble Sort）")]),t._v(" "),_("h3",{attrs:{id:"思想"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#思想"}},[t._v("#")]),t._v(" 思想")]),t._v(" "),_("ul",[_("li",[t._v("冒泡排序只会操作相邻的两个数据。")]),t._v(" "),_("li",[t._v("每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。")]),t._v(" "),_("li",[t._v("一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。")])]),t._v(" "),_("h3",{attrs:{id:"特点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),_("ul",[_("li",[t._v("优点：排序算法的基础，简单实用易于理解。")]),t._v(" "),_("li",[t._v("缺点：比较次数多，效率较低。")])]),t._v(" "),_("h2",{attrs:{id:"字符串算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#字符串算法"}},[t._v("#")]),t._v(" 字符串算法")]),t._v(" "),_("h3",{attrs:{id:"bm算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#bm算法"}},[t._v("#")]),t._v(" BM算法")]),t._v(" "),_("p",[t._v("该算法 "),_("strong",[t._v("从模式串的尾部开始匹配")]),t._v("，且拥有在最坏情况下 O(N) 的时间复杂度。有数据表明，在实践中，比 KMP 算法的实际效能高，可以快大概 3-5 倍。而且一般的文本编辑器查找都是基于这个算法。")]),t._v(" "),_("h4",{attrs:{id:"两个规则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#两个规则"}},[t._v("#")]),t._v(" 两个规则")]),t._v(" "),_("p",[t._v("以下两个规则让模式串每次向右移动 "),_("strong",[t._v("尽可能大")]),t._v(" 的距离。")]),t._v(" "),_("ul",[_("li",[t._v("坏字符规则（"),_("strong",[t._v("bad-character shift")]),t._v('）：当文本串中的某个字符跟模式串的某个字符不匹配时，我们称文本串中的这个失配字符为坏字符，此时模式串需要向右移动，移动的位数 = 坏字符在模式串中的位置 - 坏字符在模式串中最右出现的位置。此外，如果"坏字符"不包含在模式串之中，则最右出现位置为 -1。'),_("strong",[t._v("坏字符针对的是文本串。")])]),t._v(" "),_("li",[t._v("好后缀规则（"),_("strong",[t._v("good-suffix shift")]),t._v("）：当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为 -1。"),_("strong",[t._v("好后缀针对的是模式串。")])])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://pic3.zhimg.com/v2-206804130df1bc5800f8634d5482dd1e_b.jpg",alt:"border"}})]),t._v(" "),_("p",[t._v("怎么理解这个坏字符规则。")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("如果我们在模式串中的任意一个字符跟坏字符不匹配，那么久直接移动到坏字符的后面（不存在的话就：6 - （-1）= 7）移动7位")])]),t._v(" "),_("li",[_("p",[t._v("如果坏字符出现在模式串中，就把最右侧出现的坏字符在模式串的位置减去最右侧的坏字符位置（6 - 4 = 2）"),_("strong",[t._v("如果模式串中有多个 p 呢？就从最右侧计算")])])]),t._v(" "),_("li",[_("p",[t._v("如果匹配到了，表示进入好后缀原则")]),t._v(" "),_("ul",[_("li",[t._v("从最后面匹配 如果匹配到一位， 然后继续匹配前面的 直到遇到坏字符")]),t._v(" "),_("li",[t._v("但是我们已经匹配了子串，子串就是好后缀。")])])])]),t._v(" "),_("p",[t._v("具体选哪个规则，只要根据这两个规则算出移动的位数，哪个大使用哪个。")])])}],!1,null,null,null);_.default=a.exports}}]);