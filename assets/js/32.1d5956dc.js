(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{199:function(t,a,s){"use strict";s.r(a);var n=s(0),r=Object(n.a)({},(function(){this._self._c;return this._m(0)}),[function(){var t=this,a=t._self._c;return a("div",{staticClass:"content"},[a("h2",{attrs:{id:"分析算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分析算法"}},[t._v("#")]),t._v(" 分析算法")]),t._v(" "),a("p",[t._v("复杂度分析是整个算法学习的精髓。")]),t._v(" "),a("ul",[a("li",[t._v("时间复杂度: 一个算法执行所耗费的时间。(O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势)")]),t._v(" "),a("li",[t._v("空间复杂度: 运行完一个程序所需内存的大小。")])]),t._v(" "),a("h2",{attrs:{id:"分析时间复杂度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分析时间复杂度"}},[t._v("#")]),t._v(" 分析时间复杂度")]),t._v(" "),a("h3",{attrs:{id:"（循环次数最多的代码-计算执行多少次）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#（循环次数最多的代码-计算执行多少次）"}},[t._v("#")]),t._v(" （循环次数最多的代码 计算执行多少次）")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("只关注循环次数最多的代码")]),t._v(" "),a("p",[t._v("大O表示法是一种变化趋势，我们可以忽略掉公式中常量、低阶、系数。"),a("strong",[t._v("分析一段代码的复杂度的时候，我们只要关注到循环次数最多的代码")]),t._v(" 这段核心代码执行次数的 n 的量级，就是整段要分析代码的时间")])]),t._v(" "),a("li",[a("p",[t._v("单代码中如果出现多个循环，我们就取循环量级最大的那个循环。比如有一个for循环，和一个嵌套两层的for循环。我们就取两层的for循环。一般情况是 O(n^2)")])]),t._v(" "),a("li",[a("p",[t._v("乘法法则，嵌套代码的复杂度等于 嵌套代码内外复杂度的乘积")])])]),t._v(" "),a("h4",{attrs:{id:"常见的时间复杂度案例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见的时间复杂度案例"}},[t._v("#")]),t._v(" 常见的时间复杂度案例")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("复杂度量级（按照数量级递增）")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("常量级  O(1)")])]),t._v(" "),a("tr",[a("td",[t._v("对数级 O(logn)")])]),t._v(" "),a("tr",[a("td",[t._v("线性阶 O(n)")])]),t._v(" "),a("tr",[a("td",[t._v("线性对数阶 O(nlogn)")])]),t._v(" "),a("tr",[a("td",[t._v("平方阶 O(n^2) ... O(n^k)")])]),t._v(" "),a("tr",[a("td",[t._v("指数阶 O(2^n)")])]),t._v(" "),a("tr",[a("td",[t._v("阶乘阶 O(n!)")])])])]),t._v(" "),a("p",[a("strong",[t._v("对数是对求幂的逆运算，正如除法是乘法的倒数。如果a的x次方等于N（a>0，且a不等于1），那么数x叫做以a为底N的对数（logarithm），记作x=logaN。其中，a叫做对数的[底数]，N叫做[真数]")])]),t._v(" "),a("p",[a("strong",[t._v("常见的复杂度就上面这几种。最后面的两种平时也见的很少")])]),t._v(" "),a("ul",[a("li",[t._v("O(1) "),a("strong",[t._v("只要算法中不存在循环，递归语句，即使成千上万都是O(1)")])]),t._v(" "),a("li",[t._v("O(logn) 不管是log2N 还是 log3N，都统一记logN, 因为对数是可以转换。  log3n 就等于 log32 * log2n。log32 是常量 可以忽略不计。对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表logN")]),t._v(" "),a("li",[t._v("O(nlogn) "),a("strong",[t._v("如果你理解了我前面讲的O(logn)，那O(nlogn)就很容易理解了。还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是O(logn)，我们循环执行n遍，时间复杂度就是O(nlogn)了。而且，O(nlogn)也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是O(nlogn)")])])]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 常量 O(1)")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("calc")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("n")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" sum "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" sum"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对数 循环的代码的跳出条件是 2^k = n。 所以k = log2N 忽略常量 一般计 logN 二分查找算法就是logN")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("calc")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 至于 O(n) o(n^2) 等 一般看多少层循环")]),t._v("\n")])])]),a("h2",{attrs:{id:"空间复杂度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#空间复杂度"}},[t._v("#")]),t._v(" 空间复杂度")]),t._v(" "),a("p",[t._v("时间复杂度是算法的执行时间随着数据的增长的关系，那么空间复杂度就是算法所占用的存储空间与数据规模的增长关系。")]),t._v(" "),a("h2",{attrs:{id:"最好、最坏、平均、均摊时间复杂度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最好、最坏、平均、均摊时间复杂度"}},[t._v("#")]),t._v(" 最好、最坏、平均、均摊时间复杂度")]),t._v(" "),a("ul",[a("li",[t._v("最好 就是在最理想的情况下 执行代码的时间复杂度")]),t._v(" "),a("li",[t._v("最坏 在最不理想的情况下 执行代码的时间复杂度")]),t._v(" "),a("li",[t._v("平均时间复杂度")])]),t._v(" "),a("p",[a("strong",[t._v("平均时间复杂度比较复杂，以下面的例子来说最好就是第一个位置 最差就是遍历数组还是找不到 返回-1。最坏的就是O(n)。那么怎么分析平均时间复杂度呢？")])]),t._v(" "),a("ul",[a("li",[t._v("第一步 看有多少种情况 n个元素加上 -1 一共是 n+1")])]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 寻找某个值在数组中的位置")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("findPosition")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("array"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" x")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" position "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" array"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("array"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      position "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" position"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h2",{attrs:{id:"数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[t._v("#")]),t._v(" 数组")]),t._v(" "),a("h4",{attrs:{id:"数组是一种线性表数据结构，用一组连续的内存空间，来存储一组具有相同类型的数据。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组是一种线性表数据结构，用一组连续的内存空间，来存储一组具有相同类型的数据。"}},[t._v("#")]),t._v(" 数组是一种线性表数据结构，用一组连续的内存空间，来存储一组具有相同类型的数据。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("线性表")]),t._v(" "),a("p",[t._v("线性表就是数据排成一排像一条线一样的结构。每个线性表的数据最多只有前后两个方向。除了数组 链表 队列 栈也是线性表结构。")]),t._v(" "),a("p",[a("img",{attrs:{src:"",alt:"border"}})])]),t._v(" "),a("li",[a("p",[t._v("非线性表 数 图 堆。他们的数据之间并不是简单的前后关系。")])])]),t._v(" "),a("h4",{attrs:{id:"连续的内存空间和相同类型的数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#连续的内存空间和相同类型的数据"}},[t._v("#")]),t._v(" 连续的内存空间和相同类型的数据")]),t._v(" "),a("p",[a("strong",[t._v("随机访问")]),t._v(" 但是插入和删除操作很低效。为了保证连续性 就需要做大量的数据迁移工作。")]),t._v(" "),a("p",[a("strong",[t._v("首先来解释一下数组，数组因为是连续的内存空间")]),t._v(" 看代码解释比较合适")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" nums "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 假设现在分配了内存空间 1000-1039、首位地址为 base_address = 1000。计算机通过内存地址访问数据。所以当随机访问数组的时候 会通过下面的公式寻找内存地址")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// data_type_size 是int类型数据 所以data_type_size 是4个字节")]),t._v("\na"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("_address "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" base_address "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" data_type_size"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n")])])]),a("p",[a("strong",[t._v("有一个问题，很多时候大家认为数组查找操作的时间复杂度是O(1), 但是其实这种表述是不正确的，数组支持随机访问，根据下标随机访问的时间复杂度是O(1)。")])]),t._v(" "),a("h4",{attrs:{id:"删除和插入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#删除和插入"}},[t._v("#")]),t._v(" 删除和插入")]),t._v(" "),a("p",[t._v("数组的删除和插入都会导致数据的迁移，意思就是如果删除了一个元素，为了保证数组的连续性 要把后面的元素向前移。")]),t._v(" "),a("h4",{attrs:{id:"数组的下标索引为什么从0开始"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组的下标索引为什么从0开始"}},[t._v("#")]),t._v(" 数组的下标索引为什么从0开始")]),t._v(" "),a("p",[t._v("数组存储的内存模型来看，“下标”最确切的定义是 偏移。如果a表示数组的首地址。a[0]就死偏移为0的位置，也就是首地址，a[k] 就表示偏移 K个 type_size的位置。 所以计算a[k]的内存地址只需要用这个公式:")]),t._v(" "),a("p",[t._v("a[k]_address = base_address + k* type_size;")]),t._v(" "),a("p",[t._v("如果是数组1开始，那么就是")]),t._v(" "),a("p",[t._v("a[k]_address = base_address + (k - 1) * type_size;")]),t._v(" "),a("p",[t._v("这样就会让CPU多了一次减法的指令。但是更多的应该是历史原因。")]),t._v(" "),a("h2",{attrs:{id:"链表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[t._v("#")]),t._v(" 链表")]),t._v(" "),a("h3",{attrs:{id:"单链表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单链表"}},[t._v("#")]),t._v(" 单链表")]),t._v(" "),a("p",[t._v("链表通过指针将一组零散的内存卡串联到一起。内存块称为链表的 "),a("strong",[t._v("结点")]),t._v("，为了把所有结点串起来，每个链表的结点除了存储数据之外 还需要记录链上的下一个结点地址。记录下一个结点地址的指针叫做"),a("strong",[t._v("后继指针next")]),t._v("。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" => data.next => data.next => null\n")])])]),a("p",[t._v("第一个习惯称之为头结点，最后一个称之为尾结点。为节点指向的是null（空地址）。这是链表上最后一个结点。链表也支持数据的插入和查找。\n插入和删除的前提是要找到某个位置的结点。所以查找是需要依次查找的。跟数组不一样。")]),t._v(" "),a("h3",{attrs:{id:"循环链表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#循环链表"}},[t._v("#")]),t._v(" 循环链表")]),t._v(" "),a("p",[t._v("循环链表是一种特殊的单链表，单链表的尾结点指向的空地址，表示最后的节点。循环链表的尾指针指向链表的头结点。就像一个环一样 首尾相连。")]),t._v(" "),a("h3",{attrs:{id:"双向链表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双向链表"}},[t._v("#")]),t._v(" 双向链表")]),t._v(" "),a("p",[t._v("双向链表是有两个方向。每个结点不止有一个后继指针next 指向后面的结点。还有一个前驱指针prev指向前面的结点。"),a("strong",[t._v("双向链表可以支持O(1)的时间复杂度找到前驱结点。")])]),t._v(" "),a("p",[t._v("前面说单链表的插入和删除操作时间复杂度就是O(1)了。那么双向链表怎么更加高效呢？ 在实际开发中，删除一个数据无外乎两种情况：")]),t._v(" "),a("ul",[a("li",[t._v("删除结点中 ”值等于某个给定值“的结点")]),t._v(" "),a("li",[t._v("删除给定指针指向的结点")])]),t._v(" "),a("p",[t._v("第一种情况来说。必须先从头开始找到给定值的结点，然后在通过前面的指针操作删除。虽然删除时间复杂度为O(1)，但是前面查找时间复杂度O(n) 。")]),t._v(" "),a("p",[t._v("第二种情况，虽然找到删除的结点 但是删除某个节点Q的前驱节点 单链表是不支持直接获取前驱结点，还是要从头开始遍历链表找到。 直到 P -> next = Q; 说明 P 是 Q的前驱节点。")]),t._v(" "),a("p",[t._v("那么双向链表就对第二种情况来说有优势了。如果要在指定结点前面插入一个 双向链表也更有优势。")]),t._v(" "),a("h3",{attrs:{id:"如何写出链表的代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何写出链表的代码"}},[t._v("#")]),t._v(" 如何写出链表的代码")]),t._v(" "),a("h4",{attrs:{id:"理解指针或引用的含义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#理解指针或引用的含义"}},[t._v("#")]),t._v(" 理解指针或引用的含义")]),t._v(" "),a("p",[t._v("指针其实就是 "),a("strong",[t._v("存储所指对象的内存地址")]),t._v(" 例如 P —> next = Q; P结点中的next指针存储了Q节点的内存地址。")]),t._v(" "),a("h5",{attrs:{id:"谨慎指针丢失和内存泄漏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#谨慎指针丢失和内存泄漏"}},[t._v("#")]),t._v(" 谨慎指针丢失和内存泄漏")]),t._v(" "),a("h5",{attrs:{id:"哨兵策略简化难度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#哨兵策略简化难度"}},[t._v("#")]),t._v(" 哨兵策略简化难度")]),t._v(" "),a("p",[t._v("如果我们要在某个结点P中插入一个新结点。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("new_node.next = p.next;\np.next = new_node;\n")])])]),a("h5",{attrs:{id:"边界条件的处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#边界条件的处理"}},[t._v("#")]),t._v(" 边界条件的处理")]),t._v(" "),a("p",[t._v("一般来说边界情况是最容易出现问题的。所以要考虑全面 考虑到边界的情况。比如")]),t._v(" "),a("ul",[a("li",[t._v("如果链表为空")]),t._v(" "),a("li",[t._v("如果链表中只包含一个结点")]),t._v(" "),a("li",[t._v("如果链表只有两个结点")]),t._v(" "),a("li",[t._v("代码逻辑在处理头结点和尾结点的时候 要注意啥")])]),t._v(" "),a("h3",{attrs:{id:"常见的链表问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见的链表问题"}},[t._v("#")]),t._v(" 常见的链表问题")]),t._v(" "),a("ul",[a("li",[t._v("单链表反转")]),t._v(" "),a("li",[t._v("链表中是否有环")]),t._v(" "),a("li",[t._v("两个有序的链表合并")]),t._v(" "),a("li",[t._v("删除链表倒数第n个结点")]),t._v(" "),a("li",[t._v("求链表的中间节点")])]),t._v(" "),a("p",[a("strong",[t._v("写链表是最考验逻辑思维能力 很重要 反复练习")])])])}],!1,null,null,null);a.default=r.exports}}]);