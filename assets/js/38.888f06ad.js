(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{205:function(t,a,s){"use strict";s.r(a);var _=s(0),v=Object(_.a)({},(function(){this._self._c;return this._m(0)}),[function(){var t=this,a=t._self._c;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"设计原则和技巧"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计原则和技巧"}},[t._v("#")]),t._v(" 设计原则和技巧")]),t._v(" "),a("h2",{attrs:{id:"单一职责原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单一职责原则"}},[t._v("#")]),t._v(" 单一职责原则")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("SPR 原则体现在：一个对象（方法）只做一件事。")]),t._v(" 如 代理模式、迭代器模式、单例模式和装饰者模式。")])]),t._v(" "),a("h4",{attrs:{id:"何时分离职责"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#何时分离职责"}},[t._v("#")]),t._v(" 何时分离职责")]),t._v(" "),a("p",[t._v("SRP 原则是所有原则中最简单也是最难正确运用的原则之一。并不是所有的职责都应该一一分离。如果两个职责总是同时变化，那么就没有必要分开。")]),t._v(" "),a("p",[t._v("SRP 原则的优点是降低了单个类或者对象的复杂度，按照职责把对象分解成更小的粒度， 这有助于代码的复用，也有利于进行单元测试。当一个职责需要变更的时候，不会影响到其他 的职责。 但 SRP 原则也有一些缺点，最明显的是会增加编写代码的复杂度。当我们按照职责把对象 分解成更小的粒度之后，实际上也增大了这些对象之间相互联系的难度。")]),t._v(" "),a("h2",{attrs:{id:"最少知识原则-（lkp）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最少知识原则-（lkp）"}},[t._v("#")]),t._v(" 最少知识原则 （LKP）")]),t._v(" "),a("p",[a("strong",[t._v("软件实体应当尽可能少地与其他实体发生相互作用，")])]),t._v(" "),a("h3",{attrs:{id:"减少对象之间的联系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#减少对象之间的联系"}},[t._v("#")]),t._v(" 减少对象之间的联系")]),t._v(" "),a("p",[t._v("最少知识原则要求我们在设计程序时，应当尽量减少对象之间的交互。如果两个对象之间不 必彼此直接通信，那么这两个对象就不要发生直接的相互联系。常见的做法是引入一个第三者对 象，来承担这些对象之间的通信作用。如果一些对象需要向另一些对象发起请求，可以通过第三 者对象来转发这些请求。")]),t._v(" "),a("h3",{attrs:{id:"设计模式中案例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计模式中案例"}},[t._v("#")]),t._v(" 设计模式中案例")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("中介者模式")]),t._v(" "),a("p",[t._v("例如世界杯时候的博彩公司作为中介，支付宝的中间者。")])]),t._v(" "),a("li",[a("p",[t._v("外观模式")]),t._v(" "),a("p",[t._v("在JavaScript中使用的很少")])])]),t._v(" "),a("h2",{attrs:{id:"开放-封闭原则（ocp）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开放-封闭原则（ocp）"}},[t._v("#")]),t._v(" 开放-封闭原则（OCP）")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("软件实体（类、模块、函数）等应该是可以扩展的，但是不可修改。")])])]),t._v(" "),a("p",[t._v("当需要改变一个程序的功能或者给这个程序增加新功 能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码。")]),t._v(" "),a("h3",{attrs:{id:"对象的多态性消除条件分支"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象的多态性消除条件分支"}},[t._v("#")]),t._v(" 对象的多态性消除条件分支")]),t._v(" "),a("p",[t._v("利用多态的思想，我们把程序中不变的部分隔离出来，然后把可变的部分封 装起来，这样一来程序就具有了可扩展性。")]),t._v(" "),a("h3",{attrs:{id:"相对性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相对性"}},[t._v("#")]),t._v(" 相对性")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("挑选出最容易发生变化的地方，然后构造抽象来封闭这些变化。")])]),t._v(" "),a("li",[a("p",[t._v("在不可避免发生修改的时候，尽量修改那些相对容易修改的地方。拿一个开源库来说， 修改它提供的配置文件，总比修改它的源代码来得简单。")])])])])}],!1,null,null,null);a.default=v.exports}}]);