## 基本概念

> **正则表达式是由一组字母和符号组成的特殊文本，可以用来从文本中找出满足你想要的格式的句子。**
>
> **正则匹配默认是贪婪匹配，就是尽可能多的匹配文本字符串**



## 正则回溯

回溯算法是一种查找计算问题的解决方案，他会逐步构建候选解决方案，

### 举例

```js
const reg = /ab{1,3}bc/g;

// 1、正则引擎先匹配 a。
// 2、正则引擎尽可能多地(贪婪)匹配 b{1,3}中的 b。
// 3、正则引擎去匹配 b，发现没 b 了，糟糕！赶紧回溯！
// 4、返回 b{1,3}这一步，不能这么贪婪，少匹配个 b。
// 5、正则引擎去匹配 b。
// 6、正则引擎去匹配 c，完成匹配。

```

上面发生正则回溯的例子可以看出来，正则回溯的过程就是一个试错的过程，这也是回溯算法的精髓所在。回溯会增加匹配的步骤，势必会影响文本匹配的性能，所以，要想提升正则表达式的匹配性能，了解回溯出现的场景(形式)是非常关键的。



## 基本元字符

| 字符 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| .    | 匹配除了换行符之外的任何单个字符（一般范围很广的都用这个）   |
| \    | 非特殊字符之前的反斜扛表示下一个特殊字符                     |
| \|   | 逻辑或操作符 选择表达式。123\|456 匹配123 或者 456           |
| [ ]  | 定义一个字符集合，匹配字符集合中的一个字符，但是 . \ 这些字符表示自身 |
| [^]  | 不在字符集合的任意字符                                       |
| -    | 定义一个区间 例如[A-Z] 其首尾字符在ASCII字符集里面           |






## 数量元字符

| 字符   | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| {m, n} | 匹配前面一会字符至少m次到至多n次重复 单个{m}表示匹配m次，{m,}至少m次 |
| +      | 匹配前面一个表达式一次或多次 相当于{1,}                      |
| *      | 匹配前面一个表达式零次或者多次。相当于{0,} 可以一次都没有    |
| ？     | 匹配前面零次或一次 {0,1} **如果放在任何量词 * + ？ { } 后面的时候就使得量词变为非贪婪模式 （尽量匹配少的字符）** 比如 '123abc' 应用/\d+/ 会返回 '123',如果是 /\d+?/ 就会只会匹配到'1' 但是有一种情况 'aaab' 应用 /a+?b/匹配到的却是 'aaab' 整个字符串，这是因为正则表达式的模式匹配总会寻找字符串中第一个可能匹配的位置。由于该匹配是从字符串的第一个字符开始 |





## 位置元字符

| 字符    | 描述                              |
| ------- | --------------------------------- |
| ^       | 单独使用匹配表达式的开始          |
| $       | 匹配表达式的结束位置              |
| \b      | 匹配单词边界 \w 和 \W之间的位置。 |
| \B      | 匹配非单词边界                    |
| （?=p） | 匹配p前面的位置                   |
| （?!p） | 匹配不是p前面的位置               |

\b 和 \B 是单词的边界。一般是 \w 和 \W之间的位置。



## 边界 \b \B

* **\w 匹配所有的字母数字[a-zA-Z0-9_]**
* **\W 匹配一个非单字字符。等价于 `[^A-Za-z0-9_]`。**

词边界是一种检查，跟 ^ $ 是一样的。当正则引擎遇到 \b 时，会检查字符串中的位置是否是词边界。有三种单词边界

* 字符串开头，如果第一个字符串是单词字符\w
* 字符串中的两个字符之间 一个是 \w 另一个不是
* 字符串末尾 如果最后一个字符是单词字符\w









### 正向肯定预查 ?= 

```javascript
let str = '[JS] Lesson_01.mp4';
let str1 = str.replace(/\b/g, '#');
console.log(str1); // [#JS#] #Lesson_01#.#mp4#

'hello'.replace(/(?=l)/g, '#'); // 结果是 he#l#lo
'hello'.replace(/(?!l)/g, '#'); // 结果是 #h#ell#o#
```



## 只匹配不捕获 ？:

在正则表达式中，可以选择关闭对不需要的内容的捕获，就是不捕获，以此来提高正则表达式的执行速度和节约内存使用。 

**要在一篇文章中查找"program"和"project"两个单词，正则表达式可表示为/program|project/,也可表示为/pro(gram|ject)/，但是缓存子匹配(gramject)没有意义，就可以用/pro(?:gram|ject)/进行非捕获性匹配这样既可以简洁匹配又可不缓存无实际意义的字匹配**。



##  简写字符集

正则表达式提供一些常用的字符集简写。如下:

| 简写 | 描述                                               |
| ---- | -------------------------------------------------- |
| .    | 除换行符外的所有字符                               |
| \w   | 匹配所有字母数字，等同于 `[a-zA-Z0-9_]`            |
| \W   | 匹配所有非字母数字，即符号，等同于： `[^\w]`       |
| \d   | 匹配数字： `[0-9]`                                 |
| \D   | 匹配非数字： `[^\d]`                               |
| \s   | 匹配所有空格字符，等同于： `[\t\n\f\r\p{Z}]`       |
| \S   | 匹配所有非空格字符： `[^\s]`                       |
| \f   | 匹配一个换页符                                     |
| \n   | 匹配一个换行符                                     |
| \r   | 匹配一个回车符                                     |
| \t   | 匹配一个制表符                                     |
| \v   | 匹配一个垂直制表符                                 |
| \p   | 匹配 CR/LF（等同于 `\r\n`），用来匹配 DOS 行终止符 |





## 零宽度断言（前后预查）

先行断言和后发断言都属于**非捕获簇**（不捕获文本 ，也不针对组合计进行计数）。 先行断言用于判断所匹配的格式是否在另一个确定的格式之前，匹配结果不包含该确定格式（仅作为约束）。

例如，我们想要获得所有跟在 `$` 符号后的数字，我们可以使用正后发断言 `(?<=\$)[0-9\.]*`。 这个表达式匹配 `$` 开头，之后跟着 `0,1,2,3,4,5,6,7,8,9,.` 这些字符可以出现大于等于 0 次。

零宽度断言如下：

| 符号 | 描述            |
| ---- | --------------- |
| ?=   | 正先行断言-存在 |
| ?!   | 负先行断言-排除 |
| ?<=  | 正后发断言-存在 |
| ?<!  | 负后发断言-排除 |

### 

### `?=...` 正先行断言

`?=...` 正先行断言，表示第一部分表达式之后必须跟着 `?=...`定义的表达式。

返回结果只包含满足匹配条件的第一部分表达式。 定义一个正先行断言要使用 `()`。在括号内部使用一个问号和等号： `(?=...)`。

正先行断言的内容写在括号中的等号后面。 例如，表达式 `(T|t)he(?=\sfat)` 匹配 `The` 和 `the`，在括号中我们又定义了正先行断言 `(?=\sfat)` ，即 `The` 和 `the` 后面紧跟着 `(空格)fat`。

### `?!...` 负先行断言

负先行断言 `?!` 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。 `正先行断言` 定义和 `负先行断言` 一样，区别就是 `=` 替换成 `!` 也就是 `(?!...)`。



### `?<= ...` 正后发断言

正后发断言 记作`(?<=...)` 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。



### `?<!...` 负后发断言

负后发断言 记作 `(?<!...)` 用于筛选所有匹配结果，筛选条件为 其前不跟随着断言中定义的格式。



> **总结 零宽断言 只会匹配不会捕获 用来做约束**

| 模式      | 类型         | 匹配                      |
| :-------- | :----------- | :------------------------ |
| `x(?=y)`  | 前瞻肯定断言 | `x` ，仅当后面跟着 `y`    |
| `x(?!y)`  | 前瞻否定断言 | `x` ，仅当后面不跟 `y`    |
| `(?<=y)x` | 后瞻肯定断言 | `x` ，仅当跟在 `y` 后面   |
| `(?<!y)x` | 后瞻否定断言 | `x` ，仅当不跟在 `y` 后面 |



## 贪婪和非贪婪

正则表达式里面默认是贪婪匹配的。**量词后面加？就是非贪婪 一定要记得是量词**

#### 贪婪

```js
tr = "AB1111BA111BA";
reg = /AB[\s\S]+BA/;
console.log(str.match(reg));

// 匹配过程
REG: /AB[\s\S]+BA/
MATCH: A               匹配第一个字符
       AB              匹配第二个字符
       AB1111BA111BA   [\s\S]+ 贪婪吞并所有字符
       AB1111BA111BA   回溯，匹配字符B
       AB1111BA111B    找到字符B，继续匹配A
       AB1111BA111BA   找到字符A，匹配完成，停止
```

首先是匹配AB，遇到了 `[\s\S]+`，这是贪婪模式的匹配，他会一口吞掉后面所有的字符，也就是如果 reg 的内容为 AB[\s\S]+，那后面的就不用看了，直接全部匹配，**而往后看，正则后面还有B字符，所以他会先回溯到倒数第一个字符，匹配看是否为 B，显然倒数第一个字符不是B，于是他又接着回溯，找到了B字母，找到之后就不继续回溯了（回溯）**而是往后继续匹配，此刻匹配的是字符A，程序发现紧跟B后的字母确实是A，那此时匹配就结束了。



#### 非贪婪 惰性匹配 在量词后面添加一个问号 ？来启用 惰性匹配

```js
str = "AB1111BA111BA";
reg = /AB[\s\S]+?BA/;
console.log(str.match(reg));

// 匹配过程
 REG: /AB[\s\S]+BA/
MATCH: A               匹配第一个字符
       AB              匹配第二个字符
       AB              [\s\S]+? 非贪婪跳过并开始匹配B
       AB1             不是B，回溯，继续匹配
       AB11            不是B，回溯，继续匹配
       AB111           不是B，回溯，继续匹配
       AB1111          不是B，回溯，继续匹配
       AB1111B         找到字符B，继续匹配A
       AB1111BA        找到字符A，匹配完成，停止匹配
```

与上面不同的是，reg 中多了一个 ? 号，此时的匹配模式为懒惰模式，也叫做非贪婪匹配。此时的匹配流程是，先匹配AB，遇到[\s\S]+?，程序尝试跳过并开始匹配后面的字符B，往后查看的时候，发现是数字1，不是要匹配的内容，继续往后匹配，知道遇到字符B，然后匹配A，发现紧接着B后面就有一个A，于是宣布匹配完成，停止程序。





## 分组和分支结构

比如 /(abc)+/ 一个或多个abc字符串，用这些()包起来的地方就叫分组。



#### 引用分组

**提取数据**

比如要用正则来匹配一个日期格式，yyyy-mm-dd，可以写出简单的正则`/\d{4}-\d{2}-\d{2}/`，这个正则还可以改成分组形式的`/(\d{4})-(\d{2})-(\d{2})/`这样可以分别提取出一个日期的年月日，用 String 的 match 方法或者用正则的 exec 方法都可以

 ```javascript
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-08-09";
console.log( string.match(regex) ); 
// => ["2017-08-09", "2017", "08", "09", index: 0, input: "2017-08-09"]
 ```



## 回溯

例如 /ab{1,3}bbc/.test('abbbc'); 这个是怎么匹配的呢。

搜索这种状态触发所能达到的所有"状态"，当第一条路走到尽头，会回退一步或若干步，从另一种可能状态出发继续搜索。直到所有路径都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法” 。

贪婪和非贪婪的匹配都会产生回溯，不同的是贪婪的是先尽量多的匹配，如果不行就吐出一个然后继续匹配，再不行就再吐出一个，非贪婪的是先尽量少的匹配。如果不行就再多匹配一个，再不行就再来一个 。

分支结构也会产生回溯，比如`/^(test|te)sts$/.test('tests')` 前面括号里面的匹配过程是先匹配到 test 然后继续往后匹配匹配到字符 `s` 的时候还是成功的，匹配到 `st` 的时候发现不能匹配， 所以会回到前面的分支结构的其他分支继续匹配，如果不行的话再换其他分支。



## 怎么读正则

**结构和操作符**

结构：字符字面量、字符组、量词、锚字符、分组、选择分支、方向引用

操作符：

1. 转义符 \
2. 括号和方括号 (...)、(?:...)、(?=...)、(?!...)、[...]
3. 量词限定符 {m}、{m,n}、{m,}、?、*、+
4. 位置和序列 ^ 、$、 \元字符、 一般字符
5. 管道符（竖杠） |

操作符的优先级是从上到下，由高到低的，所以在分析正则的时候可以根据优先级来拆分正则，比如 

/ab?(c|de*)+|fg/

1. 因为括号是一个整体，所以`/ab?()+|fg/`,括号里面具体是什么可以放到后面再分析
2. 根据量词和管道符的优先级，所以`a`, `b?`, `()+`和管道符后面的`f`, `g`
3. 同理分析括号里面的`c|de*` => `c`和`d`, `e*`
4. 综上，这个正则描述的是



![](https://github.com/facebook201/sy-fontend-system/blob/master/img/reg.jpg?raw=true)

### 实用案例

```javascript
let reg = /^([1-9]\d*|0)(\.\d{1,2})?$/; // 最多保留两位小数的数字

let test1 = '1234567890';
let format2 = test1.replace(/(?!^)(?=(\d{3})+$)/g, ',');
let format = test1.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
/* /\B(?=(\d{3})+(?!\d))/g：正则匹配边界\B，边界后面必须跟着(\d{3})+(?!\d);
(\d{3})+：必须是1个或多个的3个连续数字;
(?!\d)：第2步中的3个数字不允许后面跟着数字;
(\d{3})+(?!\d)：所以匹配的边界后面必须跟着3*n（n>=1）的数字。*/

```



