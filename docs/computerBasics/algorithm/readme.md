
# 算法基础

## 分析算法
复杂度分析是整个算法学习的精髓。

* 时间复杂度: 一个算法执行所耗费的时间。
* 空间复杂度: 运行完一个程序所需内存的大小。

## 执行效率

1. 最好情况、最坏情况、平均情况时间复杂度
我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。
除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。
2. 时间复杂度的系数、常数 、低阶
我们知道，时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。
但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。
3. 比较次数和交换（或移动）次数
这一节和下一节讲的都是基于比较的排序算法。基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。
所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。

## 内存消耗
内排序：所有排序操作都在内存中完成

外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；

原地排序：原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。

## 稳定性

稳定：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变
比如： a 原本在 b 前面，而 a = b，排序之后，a 仍然在 b 的前面；

不稳定：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序改变。
比如：a 原本在 b 的前面，而 a = b，排序之后， a 在 b 的后面；
