
# 算法基础

:::tip
**其实在实际的工作中，我们的业务代码在整个项目中占的体积一般在5%以内的。绝大部分的代码都在90%之中，也就是说你的项目90%是别人的，而且90%的代码是10%的人在贡献。**
:::

### 前端算法的场景

#### VDOM
VDOM逻辑上是抽象DOM的，底层上VDOM普遍实现是基于hash table这种数据结构的。
``` javascript
{
  type: 'div',
  props: {
    name: 'shiyao'
  },
  children: [
    {
      type:  'span',
      props: {},
      children: []
    }
  ]
}
```
这是一种递归的数据结构，VDOM是对DOM的抽象，所以可以根据VDOM创建一个对应真实的DOM。

#### Hooks

Hooks 是React16添加的一个新功能。解决的问题是状态逻辑复用。逻辑上解决了纯函数无法持久化状态的问题。


## 执行效率

1. 最好情况、最坏情况、平均情况时间复杂度
我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。
除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。
2. 时间复杂度的系数、常数 、低阶
我们知道，时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。
但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。
3. 比较次数和交换（或移动）次数
这一节和下一节讲的都是基于比较的排序算法。基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。
所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。

## 内存消耗
内排序：所有排序操作都在内存中完成

外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；

原地排序：原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。

## 稳定性

稳定：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变
比如： a 原本在 b 前面，而 a = b，排序之后，a 仍然在 b 的前面；

不稳定：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序改变。
比如：a 原本在 b 的前面，而 a = b，排序之后， a 在 b 的后面；
