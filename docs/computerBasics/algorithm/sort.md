# 算法

## 排序算法（Bubble Sort）
### 思想
* 冒泡排序只会操作相邻的两个数据。
* 每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。
* 一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

### 特点

* 优点：排序算法的基础，简单实用易于理解。
* 缺点：比较次数多，效率较低。









## 字符串算法



### BM算法

该算法 **从模式串的尾部开始匹配**，且拥有在最坏情况下 O(N) 的时间复杂度。有数据表明，在实践中，比 KMP 算法的实际效能高，可以快大概 3-5 倍。而且一般的文本编辑器查找都是基于这个算法。



#### 两个规则

以下两个规则让模式串每次向右移动 **尽可能大** 的距离。

- 坏字符规则（**bad-character shift**）：当文本串中的某个字符跟模式串的某个字符不匹配时，我们称文本串中的这个失配字符为坏字符，此时模式串需要向右移动，移动的位数 = 坏字符在模式串中的位置 - 坏字符在模式串中最右出现的位置。此外，如果"坏字符"不包含在模式串之中，则最右出现位置为 -1。**坏字符针对的是文本串。**
- 好后缀规则（**good-suffix shift**）：当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为 -1。**好后缀针对的是模式串。**



![border](https://pic3.zhimg.com/v2-206804130df1bc5800f8634d5482dd1e_b.jpg)

怎么理解这个坏字符规则。

* 如果我们在模式串中的任意一个字符跟坏字符不匹配，那么久直接移动到坏字符的后面（不存在的话就：6 - （-1）= 7）移动7位

* 如果坏字符出现在模式串中，就把最右侧出现的坏字符在模式串的位置减去最右侧的坏字符位置（6 - 4 = 2）**如果模式串中有多个 p 呢？就从最右侧计算**

  

* 如果匹配到了，表示进入好后缀原则

  * 从最后面匹配 如果匹配到一位， 然后继续匹配前面的 直到遇到坏字符
  * 但是我们已经匹配了子串，子串就是好后缀。



具体选哪个规则，只要根据这两个规则算出移动的位数，哪个大使用哪个。



