
## 分析算法
复杂度分析是整个算法学习的精髓。

* 时间复杂度: 一个算法执行所耗费的时间。(O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势)
* 空间复杂度: 运行完一个程序所需内存的大小。


## 分析时间复杂度 

### （循环次数最多的代码 计算执行多少次）

* 只关注循环次数最多的代码

  大O表示法是一种变化趋势，我们可以忽略掉公式中常量、低阶、系数。**分析一段代码的复杂度的时候，我们只要关注到循环次数最多的代码** 这段核心代码执行次数的 n 的量级，就是整段要分析代码的时间

* 单代码中如果出现多个循环，我们就取循环量级最大的那个循环。比如有一个for循环，和一个嵌套两层的for循环。我们就取两层的for循环。一般情况是 O(n^2)

* 乘法法则，嵌套代码的复杂度等于 嵌套代码内外复杂度的乘积



#### 常见的时间复杂度案例

| 复杂度量级（按照数量级递增） |
| ---------------------------- |
| 常量级  O(1)                 |
| 对数级 O(logn)               |
| 线性阶 O(n)                  |
| 线性对数阶 O(nlogn)          |
| 平方阶 O(n^2) ... O(n^k)     |
| 指数阶 O(2^n)                |
| 阶乘阶 O(n!)                 |



**对数是对求幂的逆运算，正如除法是乘法的倒数。如果a的x次方等于N（a>0，且a不等于1），那么数x叫做以a为底N的对数（logarithm），记作x=logaN。其中，a叫做对数的[底数]，N叫做[真数]**



**常见的复杂度就上面这几种。最后面的两种平时也见的很少**

* O(1) **只要算法中不存在循环，递归语句，即使成千上万都是O(1)**
* O(logn) 不管是log2N 还是 log3N，都统一记logN, 因为对数是可以转换。  log3n 就等于 log32 * log2n。log32 是常量 可以忽略不计。对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表logN
* O(nlogn) **如果你理解了我前面讲的O(logn)，那O(nlogn)就很容易理解了。还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是O(logn)，我们循环执行n遍，时间复杂度就是O(nlogn)了。而且，O(nlogn)也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是O(nlogn)**



```javascript
// 常量 O(1)
function calc(n) {
	let i = 1;
  let sum = n;
  return i + sum;
}

// 对数 循环的代码的跳出条件是 2^k = n。 所以k = log2N 忽略常量 一般计 logN 二分查找算法就是logN
function calc() {
  let i = 1;
  while (i <= n) {
    i = i * 2;
  }
}

// 至于 O(n) o(n^2) 等 一般看多少层循环
```



## 空间复杂度 

时间复杂度是算法的执行时间随着数据的增长的关系，那么空间复杂度就是算法所占用的存储空间与数据规模的增长关系。



## 最好、最坏、平均、均摊时间复杂度

* 最好 就是在最理想的情况下 执行代码的时间复杂度
* 最坏 在最不理想的情况下 执行代码的时间复杂度
* 平均时间复杂度

**平均时间复杂度比较复杂，以下面的例子来说最好就是第一个位置 最差就是遍历数组还是找不到 返回-1。最坏的就是O(n)。那么怎么分析平均时间复杂度呢？**

* 第一步 看有多少种情况 n个元素加上 -1 一共是 n+1

```javascript
// 寻找某个值在数组中的位置
function findPosition(array, x) {
  let position = -1;
  for (let i = 0; i < array.length; ++i) {
    if (array[i] === x) {
      position = i;
      break;
    }
  }
  return position;
}
```



## 数组





#### 数组是一种线性表数据结构，用一组连续的内存空间，来存储一组具有相同类型的数据。

* 线性表

  线性表就是数据排成一排像一条线一样的结构。每个线性表的数据最多只有前后两个方向。除了数组 链表 队列 栈也是线性表结构。

  ![border]()

* 非线性表 数 图 堆。他们的数据之间并不是简单的前后关系。



#### 连续的内存空间和相同类型的数据

**随机访问** 但是插入和删除操作很低效。为了保证连续性 就需要做大量的数据迁移工作。

**首先来解释一下数组，数组因为是连续的内存空间** 看代码解释比较合适

```javascript
let nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// 假设现在分配了内存空间 1000-1039、首位地址为 base_address = 1000。计算机通过内存地址访问数据。所以当随机访问数组的时候 会通过下面的公式寻找内存地址

// data_type_size 是int类型数据 所以data_type_size 是4个字节
a[i]_address = base_address + i * data_type_size; 
```

**有一个问题，很多时候大家认为数组查找操作的时间复杂度是O(1), 但是其实这种表述是不正确的，数组支持随机访问，根据下标随机访问的时间复杂度是O(1)。** 





#### 删除和插入

数组的删除和插入都会导致数据的迁移，意思就是如果删除了一个元素，为了保证数组的连续性 要把后面的元素向前移。



#### 数组的下标索引为什么从0开始

数组存储的内存模型来看，“下标”最确切的定义是 偏移。如果a表示数组的首地址。a[0]就死偏移为0的位置，也就是首地址，a[k] 就表示偏移 K个 type_size的位置。 所以计算a[k]的内存地址只需要用这个公式:

a[k]_address = base_address + k* type_size;

如果是数组1开始，那么就是

a[k]_address = base_address + (k - 1) * type_size;

这样就会让CPU多了一次减法的指令。但是更多的应该是历史原因。





## 链表

### 单链表
链表通过指针将一组零散的内存卡串联到一起。内存块称为链表的 **结点**，为了把所有结点串起来，每个链表的结点除了存储数据之外 还需要记录链上的下一个结点地址。记录下一个结点地址的指针叫做**后继指针next**。
```
 => data.next => data.next => null
```
第一个习惯称之为头结点，最后一个称之为尾结点。为节点指向的是null（空地址）。这是链表上最后一个结点。链表也支持数据的插入和查找。
插入和删除的前提是要找到某个位置的结点。所以查找是需要依次查找的。跟数组不一样。



### 循环链表

循环链表是一种特殊的单链表，单链表的尾结点指向的空地址，表示最后的节点。循环链表的尾指针指向链表的头结点。就像一个环一样 首尾相连。



### 双向链表

双向链表是有两个方向。每个结点不止有一个后继指针next 指向后面的结点。还有一个前驱指针prev指向前面的结点。**双向链表可以支持O(1)的时间复杂度找到前驱结点。** 

前面说单链表的插入和删除操作时间复杂度就是O(1)了。那么双向链表怎么更加高效呢？ 在实际开发中，删除一个数据无外乎两种情况：

* 删除结点中 ”值等于某个给定值“的结点
* 删除给定指针指向的结点



第一种情况来说。必须先从头开始找到给定值的结点，然后在通过前面的指针操作删除。虽然删除时间复杂度为O(1)，但是前面查找时间复杂度O(n) 。

第二种情况，虽然找到删除的结点 但是删除某个节点Q的前驱节点 单链表是不支持直接获取前驱结点，还是要从头开始遍历链表找到。 直到 P -> next = Q; 说明 P 是 Q的前驱节点。

那么双向链表就对第二种情况来说有优势了。如果要在指定结点前面插入一个 双向链表也更有优势。



### 如何写出链表的代码

#### 理解指针或引用的含义

指针其实就是 **存储所指对象的内存地址** 例如 P —> next = Q; P结点中的next指针存储了Q节点的内存地址。



##### 谨慎指针丢失和内存泄漏

##### 哨兵策略简化难度

如果我们要在某个结点P中插入一个新结点。

```
new_node.next = p.next;
p.next = new_node;
```



##### 边界条件的处理

一般来说边界情况是最容易出现问题的。所以要考虑全面 考虑到边界的情况。比如

* 如果链表为空 
* 如果链表中只包含一个结点
* 如果链表只有两个结点
* 代码逻辑在处理头结点和尾结点的时候 要注意啥



### 常见的链表问题

* 单链表反转
* 链表中是否有环
* 两个有序的链表合并
* 删除链表倒数第n个结点
* 求链表的中间节点



**写链表是最考验逻辑思维能力 很重要 反复练习**
















