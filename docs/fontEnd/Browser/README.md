# 浏览器


## URL 输入到回车发生了什么

* URL解析
* DNS解析
* TCP连接
* 处理请求
* 接受响应
* 渲染页面

### GPU渲染页面

* **当改变一个元素的尺寸位置属性时，会重新布局 绘制 以及后面所有的流程，这个称之为重排，**
* **当改变颜色属性，不会重排 但还是会触发样式计算和绘制，这个就是重绘**

**页面以每秒60帧刷新率（16ms）才不会卡顿，所以如果页面绘制和布局完成还有剩余时间，js就拿到主线程的使用权，如果js执行时间过长，就会导致下一帧js没有归还主线程给页面重绘，导致下一帧动画没有按时渲染，就会产生卡顿**

> 可以通过 requesetAnimationFrame() API 来优化 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行



## 性能



### 网络相关

* DNS域解析

* 缓存

* HTTP / 2 多路复用，多个请求使用同一个TCP连接，极大加快了网页的加载速度

   

### 减少请求数

* JavaScript CSS 打包 压缩

* JavaScript控制图片 图片本身

* 尽量使用 SVG 替代图片

  

### 文件优化

* 减少图片的数量
* 小图片使用 base64
* 能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好
* 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替
* 照片使用 JPEG



### webpack

* production 会自动开启代码压缩模式
* ES6 会开启 Tree shaking 移除没有用的代码
* 优化图片
* 按照路由拆分代码 实现按需加载
* 给

















